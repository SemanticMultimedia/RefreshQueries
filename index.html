<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Scheduling Refresh Queries for Keeping Results from a SPARQL Endpoint Up-to-Date</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Scheduling Refresh Queries for Keeping Results from a SPARQL Endpoint Up-to-Date</h1>

        <p>
          <a href="http://hpi.de/meinel/lehrstuhl/team-fotos/current-phd-students/magnus-knuth.html">Magnus Knuth</a>, 
          <a href="http://olafhartig.de/">Olaf Hartig</a>, and
          <a href="http://hpi.de/meinel/lehrstuhl/team-fotos/senior-researcher/sack.html">Harald Sack</a>
        </p>

        <p>
          This work will be presented as a short paper (<a href="./knuth-m-2016-scheduling.pdf">preprint</a>) at <em>ODBASE 2016 - The 15th International Conference on Ontologies, DataBases, and Applications of Semantics</em>.
        </p>

        <p>
        An <a href="http://arxiv.org/abs/1608.08130">extended version</a> of the ODBASE paper is available at <em>arXiv.org</em>.</p>
      </header>
      <section>
        <h2>Abstract</h2>
        <p>Many datasets change over time. As a consequence, long-running applications that cache and repeatedly use query results obtained from a SPARQL endpoint may resubmit the queries regularly to ensure up-to-dateness of the results. While this approach may be feasible if the number of such regular refresh queries is manageable, with an increasing number of applications adopting this approach, the SPARQL endpoint may become overloaded with such refresh queries. Therefore, a more scalable approach would be to use a middle-ware component at which the applications register their queries and get notified with updated query results once the results have changed. Then, this middle-ware can schedule the repeated execution of the refresh queries without overloading the endpoint.
        In this paper, we study the problem of scheduling refresh queries for a large number of registered queries by assuming an overload-avoiding upper bound on the length of a regular time slot available for testing refresh queries. We investigate a variety of scheduling strategies and compare them experimentally in terms of time slots needed before they recognize changes and number of changes that they miss.</p>

        <h2>Experimental Data</h2>
        <p>We provide the data gathered from the experiments in form of a full MySQL database dump and an RDF dump with the query executions as planned by the evaluated strategies.</p>

        <p>The database dump includes the plain results of all query executions, while the RDF dataset refers to their hash values. The RDF dataset applies the <a href="https://github.com/AKSW/LSQ/blob/gh-pages/LSQ_Vocab.rdf">LSQ vocabulary</a>. We extended the vocabulary to describe relevant metadata, such as the delay and the missed updates of individual query executions.</p>

        <ul>
          <li>We randomly selected 10,000 DBpedia queries from the <a href="http://aksw.github.io/LSQ/">Linked SPARQL Queries dataset (LSQ)</a>:
            <ul>
              <li><a href="https://github.com/SemanticMultimedia/RefreshQueries/blob/gh-pages/data/queries.txt">queries.txt</a></li>
            </ul>
          </li>
          <li>Full MySQL database dump:
            <ul>
              <li><a href="http://141.89.225.50/RefreshQueries/reevaluate_query_2016-07-18.sql.gz">reevaluate_query_2016-07-18.sql.gz</a> (412K): queries with metadata</li>
              <li><a href="http://141.89.225.50/RefreshQueries/reevaluate_revision_2016-07-18.sql.gz">reevaluate_revision_2016-07-18.sql.gz</a> (45K): hourly revisions with statistics</li>
              <li><a href="http://141.89.225.50/RefreshQueries/reevaluate_query_execution_all_2016-07-18.sql.gz">reevaluate_query_execution_all_2016-07-18.sql.gz</a> (80M): all query executions with metadata (hashed query results)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/reevaluate_evaluation_2016-07-18.sql.gz">reevaluate_evaluation_2016-07-18.sql.gz</a> (295M): query re-evaluation as performed by scheduling strategies with metadata</li>
              <li><a href="http://141.89.225.50/RefreshQueries/reevaluate_results_2016-07-18.sql.gz">reevaluate_results_2016-07-18.sql.gz</a> (62G): plain query results for all query executions</li>
            </ul>
          </li>
          <li>RDF dataset:
            <ul>
              <li><a href="http://141.89.225.50/RefreshQueries/ESClairvoyant.ttl.gz/">ESClairvoyant.ttl.gz</a> (1.2M)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/ESRoundRobin.ttl.gz/">ESRoundRobin.ttl.gz</a> (130M)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/ESShortestJobFirst.ttl.gz/">ESShortestJobFirst.ttl.gz</a> (402M)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/ESLongestJobFirst.ttl.gz/">ESLongestJobFirst.ttl.gz</a> (140M)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/ESChangeRateDecay.ttl.gz/">ESChangeRateDecay.ttl.gz</a> (206M)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/ESChangeRatioJ.ttl.gz/">ESChangeRatioJ.ttl.gz</a> (74M)</li>
              <li><a href="http://141.89.225.50/RefreshQueries/ESTtl.ttl.gz/">ESTtl.ttl.gz</a> (165M)</li>
            </ul>
          </li>
        </ul>

      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
  </body>
</html>
